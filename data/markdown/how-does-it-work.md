The MicroBlocks system has three components:

* A blocks editor, which runs on a host computer during code development
* Virtual machine, which runs on the microcontroller and executes the user's code
* A communication system that updates the code on the board as the user edits scripts.

The blocks editor allows the user to create and edit blocks-based code. It also manages MicroBlocks libraries that provide additional functionality. Some libraries support sensors or output devices such as servos and NeoPixels. Others provide APIs for working with text, lists, and music. Libraries are written in MicroBlocks and can be explored, modified, and extended by users.

Like MicroPython, MicroBlocks code is compiled into bytecodes that are executed by a virtual machine running on the microcontroller. Bytecodes are low-level instructions similar to machine code, but independent of any particular processor architecture. This design makes it easy for MicroBlocks to support many different 32-bit microcontrollers. In fact, the MicroBlocks virtual machine is not restricted to microcontrollers; it also runs on Linux computers such as the Raspberry Pi.

If you'd like to learn more about bytecodes, see the [virtual machine](https://wiki.microblocks.fun/virtual_machine) page on the wiki. If you enable "advanced blocks", you can use the right-click menu on a script to view the instructions and bytecodes generated by your own scripts. That's a great way to gain a deeper understanding of how computers execute code.

The communication system sends the bytecodes for scripts to the virtual machine and updates those bytecodes as the user edits scripts. Since scripts are recompiled and sent to the virtual machine incrementally, the code is ready to go immediately. That makes it easy to test and improve your code.

The communication system also sends commands to start scripts and processes messages from the microcontroller that indicate when scripts stop or return results. That allows the editor to provide graphical feedback about what is happening on the microcontroller.

A key part of learning about sensors is seeing how they respond in real time. For example, how does acceleration change as you toss and catch the micro:bit? The communication system allows sensor values and computation result to be displayed in a little "talk bubble". It also supports graphing sensor data in real time. Graphing is a powerful tool for building intuition about real-time physical and electrical processes.
